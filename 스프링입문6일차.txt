스프링 입문 6일차

스프링 빈과 의존관계

지금까지 서비스,도메인,레포지토리를 만들었음.

이제 화면에다가 붙일건데, 그러려면 MVC패턴이 필요(View,Controller)
->멤버컨트롤러가 필요함

멤버컨트롤러:멤버 서비스를 통해서 작업을 처리할수 있어야함.
->컨트롤러가 서비스를 "의존"한다.

컨트롤러 패키지에 MemberController생성 후
"클래스명"위에 "어노테이션으로 Controller"생성.
->스프링이 시작하면서 생기는 컨테이너에 "멤버 컨트롤러 객체를 생성하고 관리"해준다.
(컨트롤러 어노테이션의 역할)
->스프링 "빈"이 관리된다라고 표현.

근데, MemberService 클래스의 객체를 "생성"해서 컨트롤러가 관리하는거면,
MemberController말고 다른 컨트롤러도 해당 객체를 생성,관리가 가능->관리 어려움

->final로 변수 지정만 해놓고, 생성자에서 멤버서비스를 인자로 받아 관리하는형태로.
@Autowired로 해당 컨트롤러와 서비스를 자동으로 연결시켜줌
근데, Service에 해당하는 클래스에 @Service 어노테이션이 없으면, 스프링에서 알지 못함.
똑같이 Repository에 해당하는 클래스에도 @Repository 어노테이션을 붙여줘야 스프링에서 앎.
->Controller(외부의 요청을 받고) Service(비즈니스 로직 만들고) Repository(데이터를 저장)
전형적인 패턴을 어노테이션으로 표시해서, 스프링이 알수있게끔 해줌.
->Controller는 Service에 의존관계를 주입받고, Service는 Repository에 의존관계를 주입받음.
(컨트롤러 쓰려면 서비스가 필요하고, 서비스를 실행하려면 데이터가 필요하니까)
->이걸 안꼬이게끔 생성자의 인자로 받아서 의존관계를 개발자가 만들어주는 형태.


**꿀팁 클래스명으로 클래스 파일 찾아 가는 단축키:ctrl+b


스프링 빈을 등록하는 방법
1.컴포넌트 스캔과 의존관계 설정
2.직접 빈 등록

우리가 썼던건 1번에 해당됨. 
컴포넌트 스캔=컨트롤러 서비스 레포지토리 어노테이션.(컴포넌트에 특화된 어노테이션)
왜 컴포넌트가 중요한가?
스프링이 등록될때 컴포넌트와 관련된 어노테이션은 모두 컨테이너에 등록해줌.
&Autowired로 의존관계를 자동으로 설정해줌.

*컴포넌트 스캔의 경우 메인메서드에서 패키지로 path설정된 경우에
해당 패키지의 하위 클래스들 중 컴포넌트를 자동으로 스캔하는 것이지,
java에 포함된 모든 클래스의 컴포넌트를 자동 스캔하는게 아니다.


스프링 실행시 스프링 컨테이너에 빈을 등록할때, 기본적으로 싱글톤으로.
싱글톤?하나의 객체만 등록해서 그 객체를 공유하는 형태.
->같은 빈이면 같은 인스턴스(객체)라고 보면 됨.


이번엔 2번 직접 빈 등록을 구현.
(어노테이션과 오토와이어를 제외하고 하나하나 직접)

일단,Controller의 컴포넌트와 Autowired는 어쩔수 없음.
서비스와 레포지토리의 경우 빈을 직접 등록할 수 있는데,
Config관련 클래스를 같은 패키지안에 만들고,
클래스엔 @Configuration 어노테이션을 빈으로 등록할 서비스와 레포지토리에는
@Bean어노테이션을 붙여준 후 return 타입의 인자로 의존관계를 설정해서 등록해준다.
이러면 똑같이 작동함.
->Controller는 service를 찾고, service는 repository를 찾으니까 역순으로 Spring 컨테이너에 등록
후 의존관계가 성립됨.


**꿀팁 오류로 인자를 넣어줘야되는데 뭘 넣어줘야될지 모르겠으면? ctrl+p하면
넣어야되는걸 알려줌.




1번과 2번의 장단점

의존성 주입은
1.필드 2.setter 3.constructor로 주입할 수 있음
우리가 만든건 3번 생성자를 만들때 인자로 받아서 넘겼음.

3번으로 만든 이유? 3번이 의존성 주입 방법중 가장 나으니까.
why? 스프링이 실행되고 컨테이너에 빈이 올라올때(APP이 조립될때) 해당 클래스들도
실행될때 생성자가 무조건 "한번만" 실행되므로 생성자에 인자로 의존성을 가진
클래스 객체를 넘겨주는게 좋음.


실무에선 정형화된 C,S,R의 경우 컴포넌트 어노테이션으로
정형화 되지 않거나,상황에 따라 구현클래스를 변경해야되는 경우
->직접 Config에 빈으로 등록한다.

딱 봐도, 1번은 쉽고 2번이 상황에 따라 유연하게 처리해야돼서 어려움
->2번이 더 중요함.

ex)정형화되게 어노테이션으로 하는 경우 memberRepository의 DB가 정해져서 코드의
수정이 필요한 경우에 1번의 경우 여러 코드의 수정이 필요하지만
2번의 경우 MemberRepository의 return 객체를 해당DBRepository로 반환하는
수정코드 한줄만 있으면 됨.

@Autowired는 빈으로 등록된 경우에만 의존관계를 자동 설정해줌.
->스프링 컨테이너에 올라온 빈들의 한해서만 작동하는 어노테이션.

























