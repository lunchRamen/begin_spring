스프링 입문 8일차

스프링 DB접근 기술

이전까지:메모리에 저장 후 실행 및 테스트 진행
->재부팅, 프로그램 재실행시 데이터들이 다시 다 초기화 됨.


실무에선 다 DB에 데이터를 저장하고 관리함.
->java에서 db를 쓰려먼 jdbc(java database driver 머시기)로 import해서 써야함
->한참 전 기술. 일단 예시로 써봄
이후엔 스프링 jdbc템플릿이랑 JPA를 써볼 예정.(+스프링 데이터JPA)

JPA:객체를 db에 쿼리없이 저장 가능.

초기단계 db부터 시작해서, 최신기술들로 어떻게 확장되는지 확인해보며 코딩해보기.



연습용으로 좋은 h2 db를 통해서 연습해볼 예정

db 만들고, 

drop table if exists member CASCADE;
create table member
(
 id bigint generated by default as identity,
 name varchar(255),
 primary key (id)
);
통해서 table 생성

id는 bigint인데 generated by default as identity,=null 입력시 db가 알아서 구별자 생성.
name은 가변문자배열 
pk는 id


db의 경우 직접적으로 쓰진 않지만, git같은 업데이트 제어시 편리를 위해
src단위 디렉토리에서 sql디렉토리를 만들고, 도메인에 해당되는 db내용 복붙해놓는게
찾아보기 편하다.



순수 jdbc
거의 쓸일 없고, 예전에 java에서 db를 어떻게 다뤘는지 확인하는 정도.

하드코딩으로 sql문 자체를 String으로 만들고, value로 넣을걸
파라미터 바인딩을 통해서 db와 Connection으로 붙여서 연동해서 쓰는 원리.
실행(excute)와 예외처리 또한 매 메서드마다 필요함.

jdbc 기본 실행 로직
String sql = "insert into member(name) values(?)";
->sql 쿼리를 String으로 만듬
pstmt = conn.prepareStatement(sql,
                    Statement.RETURN_GENERATED_KEYS);
connection을 만들고 conn객체에 sql이랑 db에 인서트한 id값을 넣게끔 key생성

setString으로 member.getName으로 이름을 넣어서
excuteUpdate로 db에 쿼리가 날라감.

try catch로 실행 예외처리 잘 해주고, 네트워크 릴리즈를 finally에 항상 해줘야 서버장애가 안남.




SpringConfig(Configuration:구성)
->스프링 컨테이너에 빈(서비스,레포지토리)를 등록했음.

여기에 MemberRepository를 Jdbc형태로 return하게끔 설정 후
datasource도 인자로 받아서 생성자로 받게끔->db에 java를 연결할수 있게끔.

여기까지 DB와 Spring의 연결에 있어서
기존 클래스,메서드 수정 없이 JdbcMemberRepository클래스 생성 후
SpringConfig에서 MemberRepository빈의 return타입 하나만 바꿔줬더니
db연결 및 실행이 됨
->자바의 객체지향적 특성. (기존 코드 수정없이 새로운 객체의 추가 및 대체로 구현이 가능하다)
->다형성을 통해 구현.
인터페이스가 상속과 비슷한 속성을 띄고있어서
MemberRepository를 구현한 JdbcMemberRepository로 return을 해도
해당 interface에 속한 구현체 중 다른것으로(Memory->jdbc) 갈아끼운것이기때문에
코드의 수정 없이 교체 구현 가능.
->DI(의존성 주입)(생성자에서 파라미터로 받아서 두 클래스간 의존성을 설정)으로도 구현.

____________________________________________________________________________________________
객체지향에 있어서 SOLID원칙
Single Responsibility Principle 단일 책임 원칙
->하나의 클래스는 하나의 기능만 가지도록 설계.
Open Close Principle 개방폐쇄원칙
->확장에 대해 개방, 수정에 대해 폐쇄되도록 설계. 코드를 변경하지 않고 확장 가능하게끔.
Liskov Subsitution Principle 리스코프 치환 원칙
->자식타입 클래스는 언제나 부모 타입 클래스로 바꿔끼울수 있도록(확장이 가능하게끔)
Interface Segregation Principle 인터페이스 분리 원칙
->인터페이스 또한 하나의 기능으로 작동하게끔 구현 하는게 낫다.(이후 합치는 방식으로)
Dependency Inversion Principle 의존성 역전 원칙 
->하위 모듈이 상위 모듈의 변경을 요청하지 못하게끔 하는 설계.
____________________________________________________________________________________________


위에 Memory->Jdbc는 개방폐쇄원칙에 따라 객체지향적으로 설계한 케이스.

구현한 두개의 구현체들중 쓸걸로 갈아끼우는 형태.


____________________________________________________________________________________________

스프링 통합 테스트

위에 구현한 java와 db의 연결된게 실행은 잘 됐는데, 
테스트 케이스를 db에 연결해서 만들어도 잘 진행되는지 확인해보자.


DB와 연결할 경우
class앞에 @SpringBootTest와 @Transactional 어노테이션이 붙어야하는데
앞에건 그렇다 치고 Transactional이 붙는 이유?
->DB는 트랜잭션이란 개념이 있음.
data를 insert query하고 commit을 해줘야 db에 반영됨.
이 커밋된 data들을 테스트 후에 roll back해주는 역할이 Transactional.
(테스트는 반복된 테스트에 대해 똑같은 결과를 줘야하니까)


"기능별 단위테스트"로 테스트를 할 수 있게끔 코드를 짜고, 스프링까지 올려서
테스트 하는 케이스들은 가급적 지양할수 있게끔 생각하고, 코딩해야한다.





























